<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=siteBaseUrl content="https://azurecodingarchitect.com/"><meta name=author content="Bas van de Sande"><meta name=description content="Tinkering with Azure and other technologies"><meta name=keywords content="blog,azure,cosmosdb,aks,kubernetes,k3s,docker,c#,visualstudio,architecture,technology,xpirit"><meta name=generator content="Hugo 0.101.0"><title>Over-The-Air device update - IoT with C# | Azure Coding Architect</title><meta name=description content="Recommission the device - apply updates and new features"><meta itemprop=name content="Over-The-Air device update - IoT with C#"><meta itemprop=description content="Recommission the device - apply updates and new features"><meta property="og:title" content="Over-The-Air device update - IoT with C#"><meta property="og:description" content="Recommission the device - apply updates and new features"><meta property="og:image" content="https://azurecodingarchitect.com/ota/ota-feature.png"><meta property="og:url" content="https://azurecodingarchitect.com/posts/ota-update/"><meta property="og:site_name" content="Azure Coding Architect"><meta property="og:type" content="article"><script src=/modernizr-simple.js></script>
<link href=/posts/ota-update/ rel=alternate type=application/rss+xml title="Azure Coding Architect"><link href=/posts/ota-update/ rel=feed type=application/rss+xml title="Azure Coding Architect"><link rel=canonical href=https://azurecodingarchitect.com/posts/ota-update/><link rel=stylesheet href=https://azurecodingarchitect.com/theme.css></head><body class=bilberry-hugo-theme><nav><div class=container><ul class=topnav><li><a href=https://xpirit.com/team/bas-van-de-sande/ target=_blank>About Me</a></li><li><a href=https://www.credly.com/users/bas-van-de-sande/badges target=_blank>Certifications</a></li></ul></div></nav><header><div class=container><div class=logo><a href=/ class=logo><img src=/bas.png alt>
<span class=overlay><i class="fa fa-home"></i></span></a></div><div class=titles><h3 class=title><a href=/>Azure Coding Architect</a></h3><span class=subtitle>Tinkering in the cloud...</span></div><div class=toggler><i class="fa fa-bars" aria-hidden=true></i></div></div></div></header><div class="main container"><div class="article-wrapper u-cf single"><a class=bubble href=https://azurecodingarchitect.com/posts/ota-update/><i class="fas fa-fw fa-pencil-alt"></i></a><article class="default article"><div class=featured-image><a href=https://azurecodingarchitect.com/posts/ota-update/><img src=/ota/ota-feature.png alt></a></div><div class=content><h1 class=article-title><a href=https://azurecodingarchitect.com/posts/ota-update/>Over-The-Air device update - IoT with C#</a></h1><div class=meta><span class="date moment">2022-08-01</span>
<span class=readingTime>10 min read</span>
<span class=categories><a href=https://azurecodingarchitect.com/categories/development/>development</a></span>
<span class=author><a href=https://azurecodingarchitect.com/author/bas-van-de-sande/>Bas van de Sande</a></span></div><p>Developing solutions for IoT devices can be a challenging task, this can also apply for getting a device at its final destination in order to do its job.
When time passes by, it is likely that either requirements or conditions are changing and that the device is not capable anymore of doing its job. In other words, it needs to be updated.
This is where the real problems may start. In many cases devices are not physically accessible or there are simply too many devices in the field to do manual updates. This is where over-the-air (OTA) updates will save your day.</p><p>In this article I describe the fundamentals for an update mechanism that can be implemented using the Nano framework.</p><h2 id=return-of-the-classics-plug-ins>Return of the classics: Plug-ins!</h2><p>As far as my knowledge reaches when it comes to the ESP32 board, flashed with the Nano framework the board comes with 4MB of memory that can be used for persistent file storage, persistent binary memory and execution memory.</p><p><img src=/ota/ota-memory.png alt="memory layout"></p><p>When I do an update of the executing binary and this fails, the device might end up in an unusable state. As long as I have access to the device this won&rsquo;t be much of a problem. In the case the device is not accessible it is. In order to overcome this problem, I need a solid main program (which does not need to be updated) that is responsible for;</p><ul><li>the Wifi connection,</li><li>the connection to Azure (disputable),</li><li>handling of software updates,</li><li>and finally the execution of the desired functionality.</li></ul><p>In other words, I need to resort to a mechanism I used in the past which is basically a plug-in based architecture. In a plug-in based architecture, the main program is nothing more than an execution platform that handles a number of system tasks. Based on a round-robin mechanism the detected plug-ins are executed.</p><p>To implement a plug-in based architecture using the Nano framework, I need to do the following:</p><ul><li>Define an interface which is known by the host.</li><li>Implement this interface on a DLL that will be loaded dynamically.</li><li>Use reflection on the host to load DLLs from a certain folder.</li><li>In case the DLL contains the specific interface, create an instance of the DLL and invoke the desired methods.</li></ul><p>In the blog post <a href=https://azurecodingarchitect.com/posts/iot-nanoframework-dps/>Register ESP32 to DPS & IoT hub - IoT with C#</a> I described how to connect the ESP32 device to the Azure IoT hub. Now that the details of the connection have been worked out, it is time for the tricky part.</p><p><img src=/ota/ota-flow.png alt="update flow"></p><p>Steps required:</p><ul><li>Get the device twin and extract the relevant data from it.</li><li>Download the binaries, check and store them if needed.</li><li>Invoke the functionality of the plug-in.</li></ul><h2 id=get-data-from-device-twin>Get data from device twin</h2><p>The first step is to retrieve the Device Twin information from the IoT hub. In this case I&rsquo;m only interested in the firmware_modules data that I added to the desired properties.</p><p><img src=/ota/ota-twin.png alt="Device Twin"></p><p>The idea of the firmware_module data in the device twin, is that I have the possibility to add additional plugins. For that I have to enter the blob storage url where the file can be retrieved from, a name for identification and a version number that can be used for version checking.</p><p>On the device I have this piece of code running that retrieves the Firmware data from the device twin.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Azure</span>
</span></span><span style=display:flex><span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DeviceClient Device { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> FirmwareData[] GetFirmwareData()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Twin deviceTwin = Device.GetTwin(<span style=color:#66d9ef>new</span> CancellationTokenSource(<span style=color:#ae81ff>10000</span>).Token);
</span></span><span style=display:flex><span>        TwinCollection desired = deviceTwin?.Properties?.Desired;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (desired != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> desiredFirmwares = desired[<span style=color:#e6db74>&#34;firmware_modules&#34;</span>] <span style=color:#66d9ef>as</span> ArrayList;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (desiredFirmwares != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                FirmwareData[] firmwares = <span style=color:#66d9ef>new</span> FirmwareData[desiredFirmwares.Count];
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> count = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> desiredFirmware <span style=color:#66d9ef>in</span> desiredFirmwares)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    FirmwareData data = (FirmwareData)JsonConvert.DeserializeObject(JsonConvert.SerializeObject(desiredFirmware), <span style=color:#66d9ef>typeof</span>(FirmwareData));
</span></span><span style=display:flex><span>                    firmwares[count++] = data;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> firmwares;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FirmwareData</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Url { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Name { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> Version { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=download-binaries-and-replace-if-needed>Download binaries and replace if needed</h2><p>Once the list of FirmwareData objects has been returned, it is time to download the binaries from Azure. The compatibility, version and name checking will eventually be done from the assembly that is retrieved from the blob storage.
The idea is to load a byte stream, then convert it to an assembly and from there on, check if the assembly implements a specific interface.</p><p>The code below shows how to download a byte array from Azure Blob Storage. In this example I allowed public read permissions on the storage container. In order for the device to download the data from Blob Storage using an HttpClient, the connection to the DeviceClient has to be closed (otherwise no connection can be made).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Azure</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DeviceClient Device { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>byte</span>[] DownloadFirmwareBytes(<span style=color:#66d9ef>string</span> firmwareLocation)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Device.IsConnected) Device.Close();
</span></span><span style=display:flex><span>        Thread.Sleep(<span style=color:#ae81ff>200</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HttpClient httpClient = <span style=color:#66d9ef>new</span>()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            SslProtocols = System.Net.Security.SslProtocols.Tls12,
</span></span><span style=display:flex><span>            HttpsAuthentCert = <span style=color:#66d9ef>new</span> X509Certificate(AzureRootCA)
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        httpClient.DefaultRequestHeaders.Add(<span style=color:#e6db74>&#34;x-ms-blob-type&#34;</span>, <span style=color:#e6db74>&#34;BlockBlob&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HttpResponseMessage response = httpClient.Get(firmwareLocation);
</span></span><span style=display:flex><span>        response.EnsureSuccessStatusCode();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>byte</span>[] bytes;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> ms = <span style=color:#66d9ef>new</span> MemoryStream())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            response.Content.ReadAsStream().CopyTo(ms);
</span></span><span style=display:flex><span>            ms.Flush();
</span></span><span style=display:flex><span>            ms.Close();
</span></span><span style=display:flex><span>            bytes = ms.ToArray();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        response.Dispose();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bytes;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Once the bytestream has been downloaded (Azure.DownloadFirmwareBytes()), an Assembly is created using the bytes. The next step is to check if the assembly contains the desired interface implementation (IsSupportedAssembly()). If the assembly contains the correct interface, a check is done to see if any plug-in stored on the device needs to be replaced (UpdateModuleCollection()). In case an existing plug-in needs to be replaced, the downloaded bytes are written to the internal persistent storage memory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> DownloadAssemblies(Azure azure)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        FirmwareData[] data = azure.GetFirmwareData();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (data == <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> updated = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (FirmwareData fw <span style=color:#66d9ef>in</span> data)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>byte</span>[] bytes = azure.DownloadFirmwareBytes(fw.Url);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (bytes != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>string</span> path = RootPath + fw.Url.Substring(fw.Url.LastIndexOf(<span style=color:#e6db74>&#39;/&#39;</span>) + <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                Assembly assembly = Assembly.Load(bytes);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (IsSupportedAssembly(assembly))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (UpdateModuleCollection(assembly, path))
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (File.Exists(path)) File.Delete(path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>using</span> (FileStream fspe = <span style=color:#66d9ef>new</span>(path, FileMode.CreateNew, FileAccess.Write))
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            fspe.Write(bytes, <span style=color:#ae81ff>0</span>, bytes.Length);
</span></span><span style=display:flex><span>                            fspe.Flush();
</span></span><span style=display:flex><span>                            fspe.Close();
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        updated = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> updated;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=invoke-the-methods-on-the-plug-in>Invoke the methods on the plug-in</h2><p>The UpdateModuleCollection() function contains the magic that we need to run the functionality within the plugin.</p><ul><li><p>From the loaded assembly, get an object instance of the first class that is implementing the interface.
This is done by getting the ConstructorInfo from the class and then Invoke() it. As a result an instance of the plug-in class is returned. Ready to be used!</p></li><li><p>Based on the type of the instance (interface type), we can get the MethodInfo the methods implemented. This is done by calling GetMethod() on the type.</p></li><li><p>Once we have the MethodInfo, we can invoke it on the instance of the plug-in class by calling the Invoke method, in which we pass in the class instance and a parameter instance.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> UpdateModuleCollection(Assembly assembly, <span style=color:#66d9ef>string</span> path)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>object</span> instance = GetObjectInstance(assembly, <span style=color:#66d9ef>out</span> Type t);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (instance == <span style=color:#66d9ef>null</span> || t == <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        MethodInfo GetName = t.GetMethod(<span style=color:#e6db74>&#34;GetName&#34;</span>);
</span></span><span style=display:flex><span>        MethodInfo GetVersion = t.GetMethod(<span style=color:#e6db74>&#34;GetVersion&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> name = GetName.Invoke(instance, <span style=color:#66d9ef>null</span>).ToString();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> version = (<span style=color:#66d9ef>int</span>)GetVersion.Invoke(instance, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (Module existing <span style=color:#66d9ef>in</span> _modules)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (existing.Name == name)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (existing.Version &lt; version)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    existing.Binary = assembly;
</span></span><span style=display:flex><span>                    existing.Version = version;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        _modules.Add(<span style=color:#66d9ef>new</span> Module { Binary = assembly, Name = name, Version = version, Path = path });
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>object</span> GetObjectInstance(Assembly assembly, <span style=color:#66d9ef>out</span> Type referencedType)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        referencedType = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (assembly == <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (Type t <span style=color:#66d9ef>in</span> assembly.GetTypes())
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (t.IsClass)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (IsSupportedClass(t))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    ConstructorInfo ctor = t.GetConstructor(<span style=color:#66d9ef>new</span> Type[] { });
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (ctor != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        referencedType = t;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> ctor.Invoke(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> IsSupportedAssembly(Assembly assembly)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (Type t <span style=color:#66d9ef>in</span> assembly.GetTypes())
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (IsSupportedClass(t)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>bool</span> IsSupportedClass(Type t)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Type[] interfaces = t.GetInterfaces();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>foreach</span> (Type intf <span style=color:#66d9ef>in</span> interfaces)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (intf == <span style=color:#66d9ef>typeof</span>(NF_AzureIot.Interfaces.IModule)) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Where we use oldskool reflection in the example above, the actual Execute() method of the plug-in is invoked the same way.
The debug output of Visual Studio below shows that we loaded the plug-in:</p><p>&ldquo;Assembly: NF_Plugin_Blinky (1.0.0.0) (240 RAM - 812 ROM - 312 METADATA)&rdquo;</p><p>and that we executed all implemented methods of the interface implemented on it.</p><pre tabindex=0><code>Attaching to nanoDevice...
Waiting for nanoDevice to initialize...
Debugger found. Resuming boot sequence.
Create Type System.
Loading Deployment Assemblies.
   Assembly: NF_AzureIoT (10.0.0.0)   (964 RAM - 8696 ROM - 2667 METADATA)
   Assembly: System.Device.Gpio (1.0.4.3)   (812 RAM - 5896 ROM - 2777 METADATA)
   Assembly: System.Net (1.9.0.8)   (2320 RAM - 20852 ROM - 9488 METADATA)
   Assembly: nanoFramework.Runtime.Events (1.10.0.3)   (596 RAM - 3412 ROM - 1799 METADATA)
   Assembly: nanoFramework.System.Collections (1.4.0.3)   (652 RAM - 4096 ROM - 2215 METADATA)
   Assembly: mscorlib (1.12.0.4)   (4020 RAM - 31832 ROM - 19179 METADATA)
   Assembly: nanoFramework.Json (2.1.2.3)   (1400 RAM - 18056 ROM - 4523 METADATA)
   Assembly: System.IO.FileSystem (1.0.3.3)   (1172 RAM - 9796 ROM - 3957 METADATA)
   Assembly: System.IO.Streams (1.0.1.1)   (856 RAM - 6728 ROM - 3024 METADATA)
   Assembly: nanoFramework.System.Text (1.1.3.13)   (644 RAM - 5828 ROM - 2292 METADATA)
   Assembly: System.Threading (1.0.4.3)   (608 RAM - 3884 ROM - 1668 METADATA)
   Assembly: System.Net.Http (1.4.0.23)   (4564 RAM - 53128 ROM - 18228 METADATA)
   Assembly: nanoFramework.Runtime.Native (1.5.4.3)   (404 RAM - 1568 ROM - 970 METADATA)
   Assembly: System.Device.Wifi (1.4.0.22)   (1048 RAM - 7244 ROM - 2933 METADATA)
   Assembly: nanoFramework.Azure.Devices.Client (1.0.1.30)   (1864 RAM - 20296 ROM - 7344 METADATA)
   Assembly: nanoFramework.M2Mqtt (5.0.2.24)   (3236 RAM - 45844 ROM - 14550 METADATA)
   Assembly: NF_Interface (1.0.0.0)   (160 RAM - 280 ROM - 98 METADATA)

Resolving.

Total: (22044 RAM - 247436 ROM - 97712 METADATA)


Ready.
The nanoDevice runtime is loading the application assemblies and starting execution.

Setting up WIFI networking!

Connect to Azure IoT hub using DPS.
Register Device Twin events
Hub status updated 4-{&#34;desired&#34;:{&#34;someProperty&#34;:&#34;none&#34;,&#34;software&#34;:{&#34;version&#34;:&#34;2.0&#34;},&#34;Firmware&#34;:&#34;https://acaiotsa.blob.core.windows.net/firmware/Blinky.pe&#34;,&#34;CodeVersion&#34;:18,&#34;firmware_modules&#34;:[{&#34;Url&#34;:&#34;https://acaiotsa.blob.core.windows.net/firmware/NF_Plugin_Blinky.pe&#34;,&#34;Name&#34;:&#34;NF_AzureIot.Plugin_blinky&#34;,&#34;Version&#34;:10}],&#34;$version&#34;:10},&#34;reported&#34;:{&#34;someProperty&#34;:&#34;new value #2 from device&#34;,&#34;Message&#34;:&#34;Updating...&#34;,&#34;$version&#34;:6}}

   Assembly: NF_Plugin_Blinky (1.0.0.0)   (240 RAM - 812 ROM - 312 METADATA)

   AssemblyRef    =       12 bytes (       3 elements)
   TypeRef        =       28 bytes (       7 elements)
   FieldRef       =        0 bytes (       0 elements)
   MethodRef      =       28 bytes (       7 elements)
   TypeDef        =        8 bytes (       1 elements)
   FieldDef       =        4 bytes (       2 elements)
   MethodDef      =       12 bytes (       5 elements)
   StaticFields   =        0 bytes (       0 elements)

   Attributes      =        0 bytes (       0 elements)
   TypeSpec        =        0 bytes (       0 elements)
   Resources       =        0 bytes (       0 elements)
   Resources Files =        0 bytes (       0 elements)
   Resources Data  =        0 bytes
   Strings         =      235 bytes
   Signatures      =       44 bytes
   ByteCode        =      138 bytes

Total: (22508 RAM - 249060 ROM - 98336 METADATA)

Handling module NF_AzureIot.Plugin_blinky v10
- Initialize
- Execute
</code></pre><h2 id=final-thoughts>Final thoughts</h2><p>Techniques shown in this post are the basis for an Over-The-Air update mechanism in which you have a fixed binary that will act as a host to run one or multiple plug-ins that are stored on the device. In the host, you have to check periodically if there are newer versions of the plug-in available after which you can download, store and execute it. The code shown is not feature complete it is a proof of concept, e.g. error handling is lacking, MD-5 checking of the downloaded file is omitted and no attempt is made to optimize the way the invoked classes are kept into memory. Optimizing the main program can be the topic for a next blog post.</p><p>I&rsquo;m impressed by the work done by the Nano framework project. Reflection on such a limited device&mldr; mind blowing! Using the Visual Studio debugger on an embedded device is insanely powerful.</p><p>Exceptions thrown by the Nanoframework can be pretty vague. What I learned in this implementation is that I need reference all Nuget packages in the host, that are being used in the plug-in (e.g. System.Device.GPIO). Otherwise an exception will occur when reflection is used on the plug-in to determine if it is the correct type. This makes the Over the Air update somehow limited, as we cannot upgrade to a newer version of the Nano framework.</p><p>Many times I ran into an issue with Visual Studio locking output binaries when recompiling the code, forcing me to restart Visual Studio. Sometimes Visual Studio crashes when stepping through code. Sometimes you have to erase the device because code that worked before throws an exception.</p><p><img src=/ota/ota-unstable.png alt="Visual Studio recovered"></p><p>Would I use the Nano framework for mission critical workloads? Not as this point, however the functionality and stability are improving very rapidly. For now I would resort to plain Arduino C and libraries available for it (or be a bit more adventurous and take a plunge with the Raspberry Pico board, running an embedded Python version), but my opinion might change in the near future.</p><p>For plain fun and nerdy hacking, this is a serious case of <strong>#DoEpicShit</strong></p></div><div class=footer><div class=tags><i class="fa fa-tags"></i><div class=links><a href=https://azurecodingarchitect.com/tags/c#/>C#</a>
<a href=https://azurecodingarchitect.com/tags/nanoframework/>nanoframework</a>
<a href=https://azurecodingarchitect.com/tags/iot/>IoT</a>
<a href=https://azurecodingarchitect.com/tags/azure/>azure</a>
<a href=https://azurecodingarchitect.com/tags/architecture/>architecture</a>
<a href=https://azurecodingarchitect.com/tags/opinion/>opinion</a></div></div></div></article></div><div id=comments-container><script src=https://giscus.app/client.js data-repo=basvandesande/azurecodingarchitect data-repo-id=R_kgDOG3nWLg data-category=General data-category-id=DIC_kwDOG3nWLs4CBPIU data-mapping=pathname data-reactions-enabled=1 data-emit-metadata data-theme=light data-lang=en crossorigin=anonymous async></script><div id=giscus></div></div></div><footer><div class=container><div class=recent-posts><strong>Latest posts</strong><ul><li><a href=https://azurecodingarchitect.com/posts/certification/>Just do it! Work on your certifications.</a></li><li><a href=https://azurecodingarchitect.com/posts/ota-update/>Over-The-Air device update - IoT with C#</a></li><li><a href=https://azurecodingarchitect.com/posts/techorama/>Techorama Antwerp 2022, human connection</a></li><li><a href=https://azurecodingarchitect.com/posts/iot-nanoframework-dps/>Register ESP32 to DPS & IoT hub - IoT with C#</a></li><li><a href=https://azurecodingarchitect.com/posts/prepare-for-iot/>From 0 to 100 in 30 minutes - IoT with C#</a></li><li><a href=https://azurecodingarchitect.com/posts/persistent-sql-docker/>Running a persistent SQL Server in Docker</a></li><li><a href=https://azurecodingarchitect.com/posts/localhost_in_kestrel/>Note to self: localhost in kestrel is localhost</a></li></ul></div><div class=categories><a href=/categories/><strong>Categories</strong></a><ul><li><a href=/categories/general>General
(5)</a></li><li><a href=/categories/development>Development
(4)</a></li><li><a href=/categories/technology>Technology
(3)</a></li><li><a href=/categories/technical>Technical
(1)</a></li></ul></div><div class=right><div class=external-profiles><strong>Social media</strong>
<a href=https://twitter.com/basvandesande target=_blank><i class="fab fa-twitter"></i></a>
<a href=https://linkdin/basvandesande target=_blank><i class="fab fa-linkedin"></i></a>
<a href="mailto:bas@vd-sande.nl?subject=[AzureCodingArchitect]" target=_blank><i class="fa fa-envelope"></i></a>
<a href=/index.xml target=_blank><i class="fas fa-rss"></i></a></div><div class=external-profiles><strong>About me</strong>
<a href=https://xpirit.com/team/bas-van-de-sande/ target=_blank><i class="fas fa-robot" &nbsp;></i></a></div></div></div></footer><div class=credits><div class=container><div class=copyright><a href=https://azurecodingarchitect.com target=_blank>&copy;
2022
- Bas van de Sande - all rights reserved</div><div class=author><a href=https://github.com/Lednerb/bilberry-hugo-theme target=_blank>Bilberry Hugo theme</a></div></div></div><script type=text/javascript src=https://azurecodingarchitect.com/theme.js></script></body></html>