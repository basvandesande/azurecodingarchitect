<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Development on Azure Coding Architect</title><link>https://azurecodingarchitect.com/categories/development/</link><description>Recent content in Development on Azure Coding Architect</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 22 Feb 2025 14:39:51 +0100</lastBuildDate><atom:link href="https://azurecodingarchitect.com/categories/development/index.xml" rel="self" type="application/rss+xml"/><item><title>The Art of Conversation</title><link>https://azurecodingarchitect.com/posts/artofconversation/</link><pubDate>Sat, 22 Feb 2025 14:39:51 +0100</pubDate><guid>https://azurecodingarchitect.com/posts/artofconversation/</guid><description>&lt;p>In the 1990&amp;rsquo;s when I did my bachelor in computer science, teachers told us that we would be replaced by 4GL languages. Languages in which end-users would describe how applications should work. At that time we laughed at them, saying we saw the exact opposite. Oh dear, we were right. Code became complexer, new concepts arrived on the horizon and software development matured. Fast forward to the 2020&amp;rsquo;s&amp;hellip;&lt;/p>
&lt;p>Over the last year, I&amp;rsquo;ve been giving a lot of GitHub Copilot training sessions world wide. Sessions in which I learned the attendees what GitHub Copilot could mean for them and how they could get the most out of it. In that time I noticed that I was particular a fan of GitHub Copilot chat. A Chat interface in which I could talk to my bestie, asking him all kinds of questions. My bestie would answer my questions as good as possible.&lt;/p></description></item><item><title>Where is that documentation? A tale on setting up diagnostic settings...</title><link>https://azurecodingarchitect.com/posts/diagnosticlogging/</link><pubDate>Fri, 29 Sep 2023 10:54:52 +0200</pubDate><guid>https://azurecodingarchitect.com/posts/diagnosticlogging/</guid><description>&lt;p>I&amp;rsquo;m a big fan of Azure and building infrastructure on it using IaC (Infrastructure as Code) and deploy it through pipelines (Azure DevOps) or workflows (Github). The last two years, I primarily used Bicep to build the infrastructure. This is often a very satisfying experience but in some cases it can be quite frustrating. Frustrating because I can&amp;rsquo;t find the information that I need in the MS Learn documentation at the location where I would expect it to be.&lt;/p></description></item><item><title>A nightmare on FrontDoor in Bicep...</title><link>https://azurecodingarchitect.com/posts/frontdoor/</link><pubDate>Tue, 18 Jul 2023 22:36:57 +0200</pubDate><guid>https://azurecodingarchitect.com/posts/frontdoor/</guid><description>&lt;p>For some reason I seem to attract the most exotic scenarios when it comes to building Infrastructure as Code (IaC). This time it was no different. For a client I&amp;rsquo;m working on building an environment in which disaster recovery is a top priority. Besides being zone redundant, the client requires region redundancy as well, in case a complete Azure region gets wiped out by a disaster or a combination of disasters&amp;hellip; My imagination gets triggered and I envision all kinds of apocalyptic movie scenarios.&lt;/p></description></item><item><title>Minikube, a lightweight Kubernetes-to-go!</title><link>https://azurecodingarchitect.com/posts/minikube/</link><pubDate>Fri, 02 Dec 2022 13:20:25 +0200</pubDate><guid>https://azurecodingarchitect.com/posts/minikube/</guid><description>&lt;p>From time-to-time I find myself tinkering with Kubernetes. I love the idea that I can create any type of workload (e.g. a simple webapp or a backend service), pick it up and put it somewhere else to run. Not having to care if it is in the cloud or on an on-premise cluster. However developing your application, testing its core in a local docker container and then deploying it to kubernetes can sometimes be cumberstone.&lt;/p></description></item><item><title>Real world mocking! Http Service testing in C# using Wiremock.Net</title><link>https://azurecodingarchitect.com/posts/wiremock_net/</link><pubDate>Fri, 28 Oct 2022 14:09:18 +0200</pubDate><guid>https://azurecodingarchitect.com/posts/wiremock_net/</guid><description>&lt;p>At Xpirit we have a culture of never ending learning. One of the best ways of learning new things, is by doing it. To take the plunge and do the deep dive.&lt;/p>
&lt;p>In this case my colleague &lt;a href="https://xpirit.com/team/kristofr/">Kristoff Riebbels&lt;/a> learned me some new tricks by introducing me into the world of WireMock.Net. Together we wrote a magazine article for &lt;a href="https://xpirit.com/download/xprt-magazine-n-13/">Xpirit Magazine #13&lt;/a>.&lt;/p>
&lt;p>In this blog post I want to share this article with you. The magazine can be downloaded from the link above.&lt;/p></description></item><item><title>Over-The-Air device update - IoT with C#</title><link>https://azurecodingarchitect.com/posts/ota-update/</link><pubDate>Mon, 01 Aug 2022 12:32:35 +0200</pubDate><guid>https://azurecodingarchitect.com/posts/ota-update/</guid><description>&lt;p>Developing solutions for IoT devices can be a challenging task, this can also apply for getting a device at its final destination in order to do its job.
When time passes by, it is likely that either requirements or conditions are changing and that the device is not capable anymore of doing its job. In other words, it needs to be updated.
This is where the real problems may start. In many cases devices are not physically accessible or there are simply too many devices in the field to do manual updates. This is where over-the-air (OTA) updates will save your day.&lt;/p></description></item><item><title>Register ESP32 to DPS &amp; IoT hub - IoT with C#</title><link>https://azurecodingarchitect.com/posts/iot-nanoframework-dps/</link><pubDate>Thu, 28 Apr 2022 21:09:06 +0200</pubDate><guid>https://azurecodingarchitect.com/posts/iot-nanoframework-dps/</guid><description>&lt;p>In my &lt;a href="https://azurecodingarchitect.com/posts/prepare-for-iot/">previous post&lt;/a> I flashed my ESP32 with the nanoframework.net, allowing me to write C# code in Visual Studio with all bells and whistles. As life goes&amp;hellip; the device landed in my drawer until this week where I had some time to experiment. This time I wanted to hook up the device to Azure IoT hub using the Device Provisioning Service (DPS) which brings me one step closer to my goal, performing device updates over-the-air&amp;hellip;&lt;/p></description></item><item><title>From 0 to 100 in 30 minutes - IoT with C#</title><link>https://azurecodingarchitect.com/posts/prepare-for-iot/</link><pubDate>Tue, 15 Mar 2022 20:28:06 +0200</pubDate><guid>https://azurecodingarchitect.com/posts/prepare-for-iot/</guid><description>&lt;p>My interest for the Internet of Things (IoT) was sparked many moons ago, way before the name was born. Back in the days I wrote software for PalmOS devices, and I was intrigued by having raw processor power in my Pocket. Don&amp;rsquo;t get me wrong, back then we where talking Megahertz instead of Gigahertz and Kilobyte instead of Gigabyte. Having such limitations in processing power and memory tickled my creativity.
When I had the opportunity to control hardware (gps, electronic locks etc) using the little devices I was sold. Fastforward to a couple of years ago when the market was flooded with Arduinos and Raspberry Pis, I picked up an old hobby and started developing again, this time playing around with sensors. The big disadvantage was that you had to resort to plain old C and a crippled development environment, until now&amp;hellip;&lt;/p></description></item><item><title>Running a persistent SQL Server in Docker</title><link>https://azurecodingarchitect.com/posts/persistent-sql-docker/</link><pubDate>Sat, 05 Mar 2022 17:46:30 +0200</pubDate><guid>https://azurecodingarchitect.com/posts/persistent-sql-docker/</guid><description>&lt;p>In IT we always want to work with the latest and greatest, it&amp;rsquo;s in our DNA to explore new technologies. From time-to-time you get confronted with legacy technologies, robust but boring. One of such things is a piece of software I wrote more than 15 years ago for a friend. It was an application using a SQL Server database that controlled a couple of weighing terminals connected over RS232. Controlling machines is every geek&amp;rsquo;s dream.
Every couple of years my friend asks me if I can help him to improve the software I wrote for him, this time it was no different.&lt;/p></description></item></channel></rss>